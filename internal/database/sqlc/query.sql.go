// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const addPostTag = `-- name: AddPostTag :exec
INSERT INTO post_tags (post_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddPostTagParams struct {
	PostID int32 `json:"post_id"`
	TagID  int32 `json:"tag_id"`
}

func (q *Queries) AddPostTag(ctx context.Context, arg AddPostTagParams) error {
	_, err := q.db.ExecContext(ctx, addPostTag, arg.PostID, arg.TagID)
	return err
}

const checkSlugExists = `-- name: CheckSlugExists :one
SELECT EXISTS(SELECT 1 FROM posts WHERE slug = $1)
`

func (q *Queries) CheckSlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSlugExistsExcept = `-- name: CheckSlugExistsExcept :one
SELECT EXISTS(SELECT 1 FROM posts WHERE slug = $1 AND id != $2)
`

type CheckSlugExistsExceptParams struct {
	Slug string `json:"slug"`
	ID   int32  `json:"id"`
}

func (q *Queries) CheckSlugExistsExcept(ctx context.Context, arg CheckSlugExistsExceptParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSlugExistsExcept, arg.Slug, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAllPosts = `-- name: CountAllPosts :one
SELECT COUNT(*) FROM posts
`

func (q *Queries) CountAllPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*) FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPostsByStatus = `-- name: CountPostsByStatus :one
SELECT COUNT(*) FROM posts WHERE status = $1
`

func (q *Queries) CountPostsByStatus(ctx context.Context, status sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPostsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPosts = `-- name: CountPublishedPosts :one
SELECT COUNT(*) FROM posts WHERE status = 'published'
`

func (q *Queries) CountPublishedPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPostsByCategory = `-- name: CountPublishedPostsByCategory :one
SELECT COUNT(*) FROM posts WHERE status = 'published' AND category_id = $1
`

func (q *Queries) CountPublishedPostsByCategory(ctx context.Context, categoryID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPostsByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPostsByTag = `-- name: CountPublishedPostsByTag :one
SELECT COUNT(*) FROM posts p
JOIN post_tags pt ON p.id = pt.post_id
WHERE p.status = 'published' AND pt.tag_id = $1
`

func (q *Queries) CountPublishedPostsByTag(ctx context.Context, tagID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPostsByTag, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchPublishedPosts = `-- name: CountSearchPublishedPosts :one
SELECT COUNT(*) FROM posts
WHERE status = 'published'
  AND (title ILIKE '%' || $1 || '%' OR content ILIKE '%' || $1 || '%')
`

func (q *Queries) CountSearchPublishedPosts(ctx context.Context, dollar_1 sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchPublishedPosts, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO admins (username, password)
VALUES ($1, $2)
RETURNING id, username, password, created_at, updated_at
`

type CreateAdminParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (Admin, error) {
	row := q.db.QueryRowContext(ctx, createAdmin, arg.Username, arg.Password)
	var i Admin
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, slug, description, sort_order)
VALUES ($1, $2, $3, $4)
RETURNING id, name, slug, description, sort_order, created_at
`

type CreateCategoryParams struct {
	Name        string         `json:"name"`
	Slug        string         `json:"slug"`
	Description sql.NullString `json:"description"`
	SortOrder   sql.NullInt32  `json:"sort_order"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.SortOrder,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (filename, original_name, path, url, mime_type, size, width, height)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, filename, original_name, path, url, mime_type, size, width, height, created_at
`

type CreateMediaParams struct {
	Filename     string         `json:"filename"`
	OriginalName string         `json:"original_name"`
	Path         string         `json:"path"`
	Url          string         `json:"url"`
	MimeType     sql.NullString `json:"mime_type"`
	Size         sql.NullInt64  `json:"size"`
	Width        sql.NullInt32  `json:"width"`
	Height       sql.NullInt32  `json:"height"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Medium, error) {
	row := q.db.QueryRowContext(ctx, createMedia,
		arg.Filename,
		arg.OriginalName,
		arg.Path,
		arg.Url,
		arg.MimeType,
		arg.Size,
		arg.Width,
		arg.Height,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalName,
		&i.Path,
		&i.Url,
		&i.MimeType,
		&i.Size,
		&i.Width,
		&i.Height,
		&i.CreatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (title, slug, content, excerpt, category_id, status, reading_time, thumbnail)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, title, slug, content, excerpt, category_id, status, view_count, reading_time, thumbnail, created_at, updated_at, published_at
`

type CreatePostParams struct {
	Title       string         `json:"title"`
	Slug        string         `json:"slug"`
	Content     string         `json:"content"`
	Excerpt     sql.NullString `json:"excerpt"`
	CategoryID  sql.NullInt32  `json:"category_id"`
	Status      sql.NullString `json:"status"`
	ReadingTime sql.NullInt32  `json:"reading_time"`
	Thumbnail   sql.NullString `json:"thumbnail"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.Excerpt,
		arg.CategoryID,
		arg.Status,
		arg.ReadingTime,
		arg.Thumbnail,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order, created_at, updated_at
`

type CreateProjectParams struct {
	Title       string                `json:"title"`
	Slug        string                `json:"slug"`
	Description sql.NullString        `json:"description"`
	Content     sql.NullString        `json:"content"`
	TechStack   pqtype.NullRawMessage `json:"tech_stack"`
	DemoUrl     sql.NullString        `json:"demo_url"`
	GithubUrl   sql.NullString        `json:"github_url"`
	Thumbnail   sql.NullString        `json:"thumbnail"`
	Images      pqtype.NullRawMessage `json:"images"`
	IsFeatured  sql.NullBool          `json:"is_featured"`
	SortOrder   sql.NullInt32         `json:"sort_order"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Content,
		arg.TechStack,
		arg.DemoUrl,
		arg.GithubUrl,
		arg.Thumbnail,
		arg.Images,
		arg.IsFeatured,
		arg.SortOrder,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.TechStack,
		&i.DemoUrl,
		&i.GithubUrl,
		&i.Thumbnail,
		&i.Images,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name, slug)
VALUES ($1, $2)
RETURNING id, name, slug, created_at
`

type CreateTagParams struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, arg.Name, arg.Slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media WHERE id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteMedia, id)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteProject, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const getAdminByID = `-- name: GetAdminByID :one
SELECT id, username, password, created_at, updated_at FROM admins WHERE id = $1
`

func (q *Queries) GetAdminByID(ctx context.Context, id int32) (Admin, error) {
	row := q.db.QueryRowContext(ctx, getAdminByID, id)
	var i Admin
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAdminByUsername = `-- name: GetAdminByUsername :one


SELECT id, username, password, created_at, updated_at FROM admins WHERE username = $1
`

// Blog API SQL Queries
// This file contains all SQL queries for sqlc code generation
// ============================================================================
// ADMINS
// ============================================================================
func (q *Queries) GetAdminByUsername(ctx context.Context, username string) (Admin, error) {
	row := q.db.QueryRowContext(ctx, getAdminByUsername, username)
	var i Admin
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, slug, description, sort_order, created_at FROM categories WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int32) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, description, sort_order, created_at FROM categories WHERE slug = $1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryBySlug, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryPostCount = `-- name: GetCategoryPostCount :one
SELECT COUNT(*) FROM posts WHERE category_id = $1 AND status = 'published'
`

func (q *Queries) GetCategoryPostCount(ctx context.Context, categoryID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCategoryPostCount, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCategoryStats = `-- name: GetCategoryStats :many
SELECT c.id, c.name, c.slug, COUNT(p.id) as post_count
FROM categories c
LEFT JOIN posts p ON c.id = p.category_id AND p.status = 'published'
GROUP BY c.id
ORDER BY post_count DESC
`

type GetCategoryStatsRow struct {
	ID        int32  `json:"id"`
	Name      string `json:"name"`
	Slug      string `json:"slug"`
	PostCount int64  `json:"post_count"`
}

func (q *Queries) GetCategoryStats(ctx context.Context) ([]GetCategoryStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategoryStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryStatsRow{}
	for rows.Next() {
		var i GetCategoryStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByID = `-- name: GetMediaByID :one
SELECT id, filename, original_name, path, url, mime_type, size, width, height, created_at FROM media WHERE id = $1
`

func (q *Queries) GetMediaByID(ctx context.Context, id int32) (Medium, error) {
	row := q.db.QueryRowContext(ctx, getMediaByID, id)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalName,
		&i.Path,
		&i.Url,
		&i.MimeType,
		&i.Size,
		&i.Width,
		&i.Height,
		&i.CreatedAt,
	)
	return i, err
}

const getPostByID = `-- name: GetPostByID :one
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.id = $1
`

type GetPostByIDRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) GetPostByID(ctx context.Context, id int32) (GetPostByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByID, id)
	var i GetPostByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getPostBySlug = `-- name: GetPostBySlug :one
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.slug = $1
`

type GetPostBySlugRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) GetPostBySlug(ctx context.Context, slug string) (GetPostBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getPostBySlug, slug)
	var i GetPostBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getPostStats = `-- name: GetPostStats :one

SELECT
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE status = 'published') as published,
    COUNT(*) FILTER (WHERE status = 'draft') as draft
FROM posts
`

type GetPostStatsRow struct {
	Total     int64 `json:"total"`
	Published int64 `json:"published"`
	Draft     int64 `json:"draft"`
}

// ============================================================================
// DASHBOARD STATS
// ============================================================================
func (q *Queries) GetPostStats(ctx context.Context) (GetPostStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getPostStats)
	var i GetPostStatsRow
	err := row.Scan(&i.Total, &i.Published, &i.Draft)
	return i, err
}

const getPostTags = `-- name: GetPostTags :many

SELECT t.id, t.name, t.slug, t.created_at FROM tags t
JOIN post_tags pt ON t.id = pt.tag_id
WHERE pt.post_id = $1
ORDER BY t.name ASC
`

// ============================================================================
// POST_TAGS
// ============================================================================
func (q *Queries) GetPostTags(ctx context.Context, postID int32) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getPostTags, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order, created_at, updated_at FROM projects WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id int32) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.TechStack,
		&i.DemoUrl,
		&i.GithubUrl,
		&i.Thumbnail,
		&i.Images,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectBySlug = `-- name: GetProjectBySlug :one
SELECT id, title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order, created_at, updated_at FROM projects WHERE slug = $1
`

func (q *Queries) GetProjectBySlug(ctx context.Context, slug string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectBySlug, slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.TechStack,
		&i.DemoUrl,
		&i.GithubUrl,
		&i.Thumbnail,
		&i.Images,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublishedPostBySlug = `-- name: GetPublishedPostBySlug :one
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.slug = $1 AND p.status = 'published'
`

type GetPublishedPostBySlugRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) GetPublishedPostBySlug(ctx context.Context, slug string) (GetPublishedPostBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getPublishedPostBySlug, slug)
	var i GetPublishedPostBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.CategoryName,
		&i.CategorySlug,
	)
	return i, err
}

const getRecentPosts = `-- name: GetRecentPosts :many
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
ORDER BY p.created_at DESC
LIMIT $1
`

type GetRecentPostsRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) GetRecentPosts(ctx context.Context, limit int32) ([]GetRecentPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentPosts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentPostsRow{}
	for rows.Next() {
		var i GetRecentPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, slug, created_at FROM tags WHERE id = $1
`

func (q *Queries) GetTagByID(ctx context.Context, id int32) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const getTagBySlug = `-- name: GetTagBySlug :one
SELECT id, name, slug, created_at FROM tags WHERE slug = $1
`

func (q *Queries) GetTagBySlug(ctx context.Context, slug string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagBySlug, slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const getTagPostCount = `-- name: GetTagPostCount :one
SELECT COUNT(*) FROM post_tags pt
JOIN posts p ON pt.post_id = p.id
WHERE pt.tag_id = $1 AND p.status = 'published'
`

func (q *Queries) GetTagPostCount(ctx context.Context, tagID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTagPostCount, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalViews = `-- name: GetTotalViews :one
SELECT COALESCE(SUM(view_count), 0) as total_views FROM posts
`

func (q *Queries) GetTotalViews(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalViews)
	var total_views interface{}
	err := row.Scan(&total_views)
	return total_views, err
}

const incrementViewCount = `-- name: IncrementViewCount :exec
UPDATE posts SET view_count = view_count + 1 WHERE id = $1
`

func (q *Queries) IncrementViewCount(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, incrementViewCount, id)
	return err
}

const listAllPosts = `-- name: ListAllPosts :many
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllPostsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllPostsRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) ListAllPosts(ctx context.Context, arg ListAllPostsParams) ([]ListAllPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllPostsRow{}
	for rows.Next() {
		var i ListAllPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many

SELECT id, name, slug, description, sort_order, created_at FROM categories ORDER BY sort_order ASC, id ASC
`

// ============================================================================
// CATEGORIES
// ============================================================================
func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedProjects = `-- name: ListFeaturedProjects :many
SELECT id, title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order, created_at, updated_at FROM projects WHERE is_featured = true ORDER BY sort_order ASC, id ASC
`

func (q *Queries) ListFeaturedProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.TechStack,
			&i.DemoUrl,
			&i.GithubUrl,
			&i.Thumbnail,
			&i.Images,
			&i.IsFeatured,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedia = `-- name: ListMedia :many

SELECT id, filename, original_name, path, url, mime_type, size, width, height, created_at FROM media ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListMediaParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// ============================================================================
// MEDIA
// ============================================================================
func (q *Queries) ListMedia(ctx context.Context, arg ListMediaParams) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, listMedia, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medium{}
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalName,
			&i.Path,
			&i.Url,
			&i.MimeType,
			&i.Size,
			&i.Width,
			&i.Height,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByStatus = `-- name: ListPostsByStatus :many
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.status = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListPostsByStatusParams struct {
	Status sql.NullString `json:"status"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

type ListPostsByStatusRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) ListPostsByStatus(ctx context.Context, arg ListPostsByStatusParams) ([]ListPostsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsByStatusRow{}
	for rows.Next() {
		var i ListPostsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many

SELECT id, title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order, created_at, updated_at FROM projects ORDER BY sort_order ASC, id ASC
`

// ============================================================================
// PROJECTS
// ============================================================================
func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.TechStack,
			&i.DemoUrl,
			&i.GithubUrl,
			&i.Thumbnail,
			&i.Images,
			&i.IsFeatured,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPosts = `-- name: ListPublishedPosts :many

SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.status = 'published'
ORDER BY p.published_at DESC
LIMIT $1 OFFSET $2
`

type ListPublishedPostsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublishedPostsRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

// ============================================================================
// POSTS
// ============================================================================
func (q *Queries) ListPublishedPosts(ctx context.Context, arg ListPublishedPostsParams) ([]ListPublishedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedPostsRow{}
	for rows.Next() {
		var i ListPublishedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPostsByCategory = `-- name: ListPublishedPostsByCategory :many
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.status = 'published' AND p.category_id = $1
ORDER BY p.published_at DESC
LIMIT $2 OFFSET $3
`

type ListPublishedPostsByCategoryParams struct {
	CategoryID sql.NullInt32 `json:"category_id"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
}

type ListPublishedPostsByCategoryRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) ListPublishedPostsByCategory(ctx context.Context, arg ListPublishedPostsByCategoryParams) ([]ListPublishedPostsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPostsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedPostsByCategoryRow{}
	for rows.Next() {
		var i ListPublishedPostsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPostsByTag = `-- name: ListPublishedPostsByTag :many
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
JOIN post_tags pt ON p.id = pt.post_id
WHERE p.status = 'published' AND pt.tag_id = $1
ORDER BY p.published_at DESC
LIMIT $2 OFFSET $3
`

type ListPublishedPostsByTagParams struct {
	TagID  int32 `json:"tag_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublishedPostsByTagRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) ListPublishedPostsByTag(ctx context.Context, arg ListPublishedPostsByTagParams) ([]ListPublishedPostsByTagRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPostsByTag, arg.TagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedPostsByTagRow{}
	for rows.Next() {
		var i ListPublishedPostsByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many

SELECT id, name, slug, created_at FROM tags ORDER BY name ASC
`

// ============================================================================
// TAGS
// ============================================================================
func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsWithPostCount = `-- name: ListTagsWithPostCount :many
SELECT t.id, t.name, t.slug, t.created_at, COUNT(pt.post_id) as post_count
FROM tags t
LEFT JOIN post_tags pt ON t.id = pt.tag_id
LEFT JOIN posts p ON pt.post_id = p.id AND p.status = 'published'
GROUP BY t.id
ORDER BY t.name ASC
`

type ListTagsWithPostCountRow struct {
	ID        int32        `json:"id"`
	Name      string       `json:"name"`
	Slug      string       `json:"slug"`
	CreatedAt sql.NullTime `json:"created_at"`
	PostCount int64        `json:"post_count"`
}

func (q *Queries) ListTagsWithPostCount(ctx context.Context) ([]ListTagsWithPostCountRow, error) {
	rows, err := q.db.QueryContext(ctx, listTagsWithPostCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTagsWithPostCountRow{}
	for rows.Next() {
		var i ListTagsWithPostCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishPost = `-- name: PublishPost :one
UPDATE posts
SET status = 'published', published_at = NOW(), updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, content, excerpt, category_id, status, view_count, reading_time, thumbnail, created_at, updated_at, published_at
`

func (q *Queries) PublishPost(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, publishPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const removeAllPostTags = `-- name: RemoveAllPostTags :exec
DELETE FROM post_tags WHERE post_id = $1
`

func (q *Queries) RemoveAllPostTags(ctx context.Context, postID int32) error {
	_, err := q.db.ExecContext(ctx, removeAllPostTags, postID)
	return err
}

const removePostTag = `-- name: RemovePostTag :exec
DELETE FROM post_tags WHERE post_id = $1 AND tag_id = $2
`

type RemovePostTagParams struct {
	PostID int32 `json:"post_id"`
	TagID  int32 `json:"tag_id"`
}

func (q *Queries) RemovePostTag(ctx context.Context, arg RemovePostTagParams) error {
	_, err := q.db.ExecContext(ctx, removePostTag, arg.PostID, arg.TagID)
	return err
}

const searchPublishedPosts = `-- name: SearchPublishedPosts :many
SELECT p.id, p.title, p.slug, p.content, p.excerpt, p.category_id, p.status, p.view_count, p.reading_time, p.thumbnail, p.created_at, p.updated_at, p.published_at, c.name as category_name, c.slug as category_slug
FROM posts p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.status = 'published'
  AND (p.title ILIKE '%' || $1 || '%' OR p.content ILIKE '%' || $1 || '%')
ORDER BY p.published_at DESC
LIMIT $2 OFFSET $3
`

type SearchPublishedPostsParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type SearchPublishedPostsRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	Content      string         `json:"content"`
	Excerpt      sql.NullString `json:"excerpt"`
	CategoryID   sql.NullInt32  `json:"category_id"`
	Status       sql.NullString `json:"status"`
	ViewCount    sql.NullInt32  `json:"view_count"`
	ReadingTime  sql.NullInt32  `json:"reading_time"`
	Thumbnail    sql.NullString `json:"thumbnail"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	PublishedAt  sql.NullTime   `json:"published_at"`
	CategoryName sql.NullString `json:"category_name"`
	CategorySlug sql.NullString `json:"category_slug"`
}

func (q *Queries) SearchPublishedPosts(ctx context.Context, arg SearchPublishedPostsParams) ([]SearchPublishedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchPublishedPosts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPublishedPostsRow{}
	for rows.Next() {
		var i SearchPublishedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.CategoryID,
			&i.Status,
			&i.ViewCount,
			&i.ReadingTime,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPostTags = `-- name: SetPostTags :exec
DELETE FROM post_tags WHERE post_id = $1
`

func (q *Queries) SetPostTags(ctx context.Context, postID int32) error {
	_, err := q.db.ExecContext(ctx, setPostTags, postID)
	return err
}

const unpublishPost = `-- name: UnpublishPost :one
UPDATE posts
SET status = 'draft', updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, content, excerpt, category_id, status, view_count, reading_time, thumbnail, created_at, updated_at, published_at
`

func (q *Queries) UnpublishPost(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, unpublishPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const updateAdminPassword = `-- name: UpdateAdminPassword :exec
UPDATE admins SET password = $2, updated_at = NOW() WHERE id = $1
`

type UpdateAdminPasswordParams struct {
	ID       int32  `json:"id"`
	Password string `json:"password"`
}

func (q *Queries) UpdateAdminPassword(ctx context.Context, arg UpdateAdminPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminPassword, arg.ID, arg.Password)
	return err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name = $2, slug = $3, description = $4, sort_order = $5
WHERE id = $1
RETURNING id, name, slug, description, sort_order, created_at
`

type UpdateCategoryParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Slug        string         `json:"slug"`
	Description sql.NullString `json:"description"`
	SortOrder   sql.NullInt32  `json:"sort_order"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.SortOrder,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET title = $2, slug = $3, content = $4, excerpt = $5, category_id = $6,
    reading_time = $7, thumbnail = $8, updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, content, excerpt, category_id, status, view_count, reading_time, thumbnail, created_at, updated_at, published_at
`

type UpdatePostParams struct {
	ID          int32          `json:"id"`
	Title       string         `json:"title"`
	Slug        string         `json:"slug"`
	Content     string         `json:"content"`
	Excerpt     sql.NullString `json:"excerpt"`
	CategoryID  sql.NullInt32  `json:"category_id"`
	ReadingTime sql.NullInt32  `json:"reading_time"`
	Thumbnail   sql.NullString `json:"thumbnail"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.Excerpt,
		arg.CategoryID,
		arg.ReadingTime,
		arg.Thumbnail,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.CategoryID,
		&i.Status,
		&i.ViewCount,
		&i.ReadingTime,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET title = $2, slug = $3, description = $4, content = $5, tech_stack = $6,
    demo_url = $7, github_url = $8, thumbnail = $9, images = $10,
    is_featured = $11, sort_order = $12, updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, description, content, tech_stack, demo_url, github_url, thumbnail, images, is_featured, sort_order, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          int32                 `json:"id"`
	Title       string                `json:"title"`
	Slug        string                `json:"slug"`
	Description sql.NullString        `json:"description"`
	Content     sql.NullString        `json:"content"`
	TechStack   pqtype.NullRawMessage `json:"tech_stack"`
	DemoUrl     sql.NullString        `json:"demo_url"`
	GithubUrl   sql.NullString        `json:"github_url"`
	Thumbnail   sql.NullString        `json:"thumbnail"`
	Images      pqtype.NullRawMessage `json:"images"`
	IsFeatured  sql.NullBool          `json:"is_featured"`
	SortOrder   sql.NullInt32         `json:"sort_order"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.ID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Content,
		arg.TechStack,
		arg.DemoUrl,
		arg.GithubUrl,
		arg.Thumbnail,
		arg.Images,
		arg.IsFeatured,
		arg.SortOrder,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.TechStack,
		&i.DemoUrl,
		&i.GithubUrl,
		&i.Thumbnail,
		&i.Images,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectOrder = `-- name: UpdateProjectOrder :exec
UPDATE projects SET sort_order = $2 WHERE id = $1
`

type UpdateProjectOrderParams struct {
	ID        int32         `json:"id"`
	SortOrder sql.NullInt32 `json:"sort_order"`
}

func (q *Queries) UpdateProjectOrder(ctx context.Context, arg UpdateProjectOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectOrder, arg.ID, arg.SortOrder)
	return err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = $2, slug = $3
WHERE id = $1
RETURNING id, name, slug, created_at
`

type UpdateTagParams struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, updateTag, arg.ID, arg.Name, arg.Slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}
